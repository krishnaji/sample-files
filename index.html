<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handy Arm</title>
    <style>
        /* Styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f0; }
        canvas { display: block; width: 100%; height: 100%; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            z-index: 100;
            display:block;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px 0;
            border-radius: 5px;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px 18px; /* Adjusted gap for potentially more controls */
            align-items: center;
            z-index: 101;
            max-width: 95%;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .control-group label {
            margin-bottom: 5px;
            font-size: 0.85em;
            white-space: nowrap;
        }
        .control-group input[type="range"] {
            width: 90px;
            cursor: pointer;
        }
        .control-group input[type="text"],
        .control-group input[type="number"] { /* Combined style for text and number inputs */
            width: 120px; /* Default width */
            padding: 5px;
            margin-top: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 0.9em;
            box-sizing: border-box; /* Ensures padding doesn't add to width */
        }
        .control-group input[type="number"].narrow { /* Specific class for narrower number input */
            width: 70px;
        }
        .control-group span {
            font-size: 0.75em;
            min-width: 30px;
            text-align: center;
            margin-top: 3px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-basis: 100%; /* Allow button group to take full width if needed */
            justify-content: center;
            margin-top: 10px;
        }
        .button-group button {
             padding: 8px 12px;
             background-color: #007bff;
             color: white;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 0.85em;
             transition: background-color 0.3s ease;
        }
        .button-group button:hover {
            background-color: #0056b3;
        }
         .button-group button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
         #waterToggle {
            background-color: #4CAF50;
         }
         #waterToggle.off {
            background-color: #f44336;
         }
         #clearSequence {
             background-color: #ffc107;
             color: #333;
         }
         #clearSequence:hover {
             background-color: #e0a800;
         }
         #demoSequenceButton {
            background-color: #17a2b8;
         }
         #demoSequenceButton:hover {
            background-color: #117a8b;
         }
         #demoSequenceButton.active {
            background-color: #dc3545;
         }
         #demoSequenceButton.active:hover {
            background-color: #c82333;
         }
         #sequenceInfo {
            font-size: 0.8em;
            margin-left: 10px;
            white-space: nowrap;
         }
         #replayStatus, #espStatus, #demoStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 1em;
            z-index: 102;
            display: none;
            text-align: center;
         }
         #espStatus {
            top: calc(50% + 70px);
            background-color: rgba(255, 100, 100, 0.8);
         }
         #demoStatus {
             top: calc(50% - 70px);
             background-color: rgba(0, 150, 255, 0.85);
         }
         #replayStatus{ /* Explicitly set top for replayStatus if it was getting overridden */
            top: 50%;
         }
         #espStatus.success {
             background-color: rgba(100, 255, 100, 0.8);
             color: #333;
         }
          #espStatus.error {
             background-color: rgba(255, 100, 100, 0.8);
             color: white;
         }
    </style>
</head>
<body>
    <div id="info">Handy Arm</div>
    <div id="replayStatus">Replaying Sequence...</div>
    <div id="demoStatus">Playing Demo...</div>
    <div id="espStatus">ESP32 Status</div>
    <div id="controls">
        <div class="control-group">
            <label for="espIpAddress">Handy Arm Address:</label>
            <input type="text" id="espIpAddress" placeholder="e.g., 192.168.4.1" value="192.168.4.1">
        </div>
        <div class="control-group">
            <label for="baseRotation">Base Rotation</label>
            <input type="range" id="baseRotation" min="0" max="180" value="90" step="1">
            <span id="baseRotationValue">90°</span>
        </div>
        <div class="control-group">
            <label for="arm1Pitch">Arm Pitch (UI)</label> <input type="range" id="arm1Pitch" min="-60" max="90" value="0" step="1"> <span id="arm1PitchValue">59°</span> </div>
        <div class="control-group">
            <label for="waterSpeed">Water Pressure</label>
            <input type="range" id="waterSpeed" min="5" max="40" value="20" step="1">
            <span id="waterSpeedValue">20</span>
        </div>
        <div class="control-group">
            <label for="holdDurationInput">Hold Duration (s)</label>
            <input type="number" id="holdDurationInput" class="narrow" min="0" max="60" value="4" step="0.5">
            <span id="holdDurationValue">4.0s</span>
        </div>
        <div class="button-group">
             <button id="waterToggle">Water ON</button>
             <button id="savePosition">Save Position</button>
             <button id="replaySequence">Replay Sequence</button>
             <button id="clearSequence">Clear Sequence</button>
             <button id="demoSequenceButton">Play Demo</button>
             <span id="sequenceInfo">Saved: 0</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, orbitControls;
        let lawn, servoBase, arm1, arm1Emitter;
        let arm1Pivot;
        let waterParticles, particleSystem;
        const waterParticleCount = 500;
        let isWatering = true;
        let waterBaseSpeed = 20;

        let lawnTextureCanvas, lawnTextureContext, lawnTexture;
        const lawnTextureSize = 512;
        const lawnWidth = 200, lawnHeight = 200;
        const dryLawnColor = '#228b22';
        const wetLawnColor = 'rgba(20, 80, 30, 0.1)';

        let baseRotationSlider, arm1PitchSlider, waterSpeedSlider;
        let baseRotationValueSpan, arm1PitchValueSpan, waterSpeedValueSpan;
        let waterToggleButton, savePositionButton, replaySequenceButton, clearSequenceButton, demoSequenceButton;
        let sequenceInfoSpan, replayStatusDiv, espIpAddressInput, espStatusDiv, demoStatusDiv;
        let holdDurationInput, holdDurationValueSpan;

        let savedSequence = [];
        let isReplaying = false;
        let replayStepIndex = 0;
        let transitionStartTime = 0;
        const transitionDuration = 1000;
        let startState = null;
        let targetState = null;
        let transitionFrameId = null;

        let isHoldingAtPosition = false;
        let holdStartTime = 0;
        let currentHoldDurationMs;

        // --- Demo Sequence Variables ---
        // These are ui_pitch values. Physical 90° = arm vertical.
        const demoSequence = [
            { base: 69, pitch: -48 }, // ui_pitch; results in physical angle approx 42°
            { base: 92, pitch: -50 }, // ui_pitch; results in physical angle approx 45.13°
            { base: 111, pitch: -47 } // ui_pitch; results in physical angle approx 42.35°
        ];
        let isDemoReplaying = false;
        let demoStepIndex = 0;
        const demoStepDelay = 2000;
        let demoTimeoutId = null;

        // --- Helper function for the NEW pitch calculation ---
        // uiPitch: angle from horizontal in UI (0=horizontal, +90=vertical/straight up)
        // returns: physical servo angle (where 90 is vertical, ~58.7 is horizontal)
        function calculatePhysicalPitchAngle(uiPitch) {
            const ui_pitch_num = parseFloat(uiPitch);
            if (isNaN(ui_pitch_num)) {
                console.error("Invalid uiPitch provided to calculatePhysicalPitchAngle:", uiPitch);
                // Default to physical angle corresponding to UI horizontal if error
                return (1350 / 23); 
            }
            // Formula: (8 * ui_pitch + 1350) / 23
            let physicalAngle = (8 * ui_pitch_num + 1350) / 23;
            // Clamp to 0-180 servo range as a safety
            physicalAngle = Math.max(0, Math.min(180, physicalAngle));
            return physicalAngle;
        }

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 100, 300);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 15, 40);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.screenSpacePanning = false;
            orbitControls.minDistance = 10;
            orbitControls.maxDistance = 100;
            orbitControls.maxPolarAngle = Math.PI / 2 - 0.05;

            createLawn();
            createServoArm();
            createWaterParticles();
            setupUIControls(); // This will call updateSliderDisplays
            window.addEventListener('resize', onWindowResize, false);
            
            // Set initial 3D model arm position from sliders' default ui_pitch
            servoBase.rotation.y = THREE.MathUtils.degToRad(parseFloat(baseRotationSlider.value));
            arm1Pivot.rotation.x = THREE.MathUtils.degToRad(parseFloat(arm1PitchSlider.value)); // ui_pitch for 3D model

            isWatering = waterToggleButton.textContent === 'Water ON';
            particleSystem.visible = isWatering;
            if(isWatering) resetWaterParticles();
        }

        // --- Object Creation ---
        function createLawn() {
            lawnTextureCanvas = document.createElement('canvas');
            lawnTextureCanvas.width = lawnTextureSize;
            lawnTextureCanvas.height = lawnTextureSize;
            lawnTextureContext = lawnTextureCanvas.getContext('2d');
            lawnTextureContext.fillStyle = dryLawnColor;
            lawnTextureContext.fillRect(0, 0, lawnTextureSize, lawnTextureSize);
            lawnTexture = new THREE.CanvasTexture(lawnTextureCanvas);
            lawnTexture.needsUpdate = true;
            const lawnGeometry = new THREE.PlaneGeometry(lawnWidth, lawnHeight);
            const lawnMaterial = new THREE.MeshStandardMaterial({
                map: lawnTexture, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1
            });
            lawn = new THREE.Mesh(lawnGeometry, lawnMaterial);
            lawn.rotation.x = -Math.PI / 2;
            lawn.position.y = -0.1;
            lawn.receiveShadow = true;
            scene.add(lawn);
        }
        function createServoArm() {
             const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.5, metalness: 0.5 });
             const armMaterial = new THREE.MeshStandardMaterial({ color: 0xd3d3d3, roughness: 0.6, metalness: 0.4 });
             const baseGeometry = new THREE.CylinderGeometry(2, 2, 1, 32);
             servoBase = new THREE.Mesh(baseGeometry, baseMaterial);
             servoBase.position.y = 0.5;
             servoBase.castShadow = true;
             servoBase.receiveShadow = true;
             scene.add(servoBase);
             arm1Pivot = new THREE.Object3D(); // This pivot controls the pitch
             arm1Pivot.position.y = 0.5;      // Positioned on top of the base
             servoBase.add(arm1Pivot);
             const arm1Geometry = new THREE.BoxGeometry(1.5, 8, 1.5); // Length 8
             arm1 = new THREE.Mesh(arm1Geometry, armMaterial);
             // Offset arm so rotation happens at one end, making it effectively horizontal at 0 rad ui_pitch
             arm1.position.y = 4; // Pivot at the base of the arm segment
             arm1.castShadow = true;
             arm1.receiveShadow = true;
             arm1Pivot.add(arm1);
             arm1Emitter = new THREE.Object3D();
             arm1Emitter.position.y = 4; // Tip of the arm segment (relative to arm1's center)
             arm1.add(arm1Emitter); // Emitter is at the end of arm1
        }
        function createWaterParticles() {
             const particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xaaaaee, size: 0.3, transparent: true, opacity: 0.7,
                blending: THREE.AdditiveBlending, depthWrite: false
            });
            for (let i = 0; i < waterParticleCount; i++) {
                positions.push(0, 0, 0);
                velocities.push(new THREE.Vector3());
            }
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.userData.velocities = velocities;
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            particleSystem.visible = isWatering;
            scene.add(particleSystem);
        }

        // --- UI Controls Setup ---
        function setupUIControls() {
            espIpAddressInput = document.getElementById('espIpAddress');
            espStatusDiv = document.getElementById('espStatus');
            demoStatusDiv = document.getElementById('demoStatus');
            baseRotationSlider = document.getElementById('baseRotation');
            arm1PitchSlider = document.getElementById('arm1Pitch');
            waterSpeedSlider = document.getElementById('waterSpeed');
            baseRotationValueSpan = document.getElementById('baseRotationValue');
            arm1PitchValueSpan = document.getElementById('arm1PitchValue');
            waterSpeedValueSpan = document.getElementById('waterSpeedValue');
            waterToggleButton = document.getElementById('waterToggle');
            savePositionButton = document.getElementById('savePosition');
            replaySequenceButton = document.getElementById('replaySequence');
            clearSequenceButton = document.getElementById('clearSequence');
            demoSequenceButton = document.getElementById('demoSequenceButton');
            sequenceInfoSpan = document.getElementById('sequenceInfo');
            replayStatusDiv = document.getElementById('replayStatus');
            holdDurationInput = document.getElementById('holdDurationInput');
            holdDurationValueSpan = document.getElementById('holdDurationValue');

            baseRotationSlider.addEventListener('input', handleSliderInput);
            arm1PitchSlider.addEventListener('input', handleSliderInput);
            waterSpeedSlider.addEventListener('input', handleSliderInput);
            waterToggleButton.addEventListener('click', toggleWater);
            savePositionButton.addEventListener('click', savePosition);
            replaySequenceButton.addEventListener('click', startReplay);
            clearSequenceButton.addEventListener('click', clearSequence);
            demoSequenceButton.addEventListener('click', toggleDemoReplay);
            holdDurationInput.addEventListener('input', handleHoldDurationChange);

            updateSliderDisplays(); // Initialize slider display values
            updateSequenceInfo();
            updateWaterButton();
            handleHoldDurationChange();
        }

        // --- ESP32 Communication ---
        async function sendServoCommand(servoName, angle) {
            const ipAddress = espIpAddressInput.value.trim();
            if (!ipAddress) {
                showEspStatus("Error: ESP32 IP Address is not set.", true);
                return;
            }
            const url = `http://${ipAddress}/set_servo_${servoName}?angle=${angle}`;
            const servoNameDisplay = servoName.charAt(0).toUpperCase() + servoName.slice(1);
            showEspStatus(`Sending: ${servoNameDisplay} to ${angle}°...`, false, true);
            try {
                await fetch(url, { mode: 'no-cors' });
                showEspStatus(`${servoNameDisplay} command to ${angle}° dispatched.`, false);
            } catch (error) {
                console.error(`Error sending command for ${servoNameDisplay} to ESP32:`, error);
                showEspStatus(`Network Error: Could not dispatch ${servoNameDisplay} command. Check connection/IP.`, true);
            }
        }
        function showEspStatus(message, isError, isPending = false) {
            espStatusDiv.textContent = message;
            espStatusDiv.style.display = 'block';
            espStatusDiv.classList.remove('success', 'error');
            espStatusDiv.style.backgroundColor = '';

            if (isError) {
                espStatusDiv.classList.add('error');
            } else if (isPending) {
                espStatusDiv.style.backgroundColor = 'rgba(100, 100, 255, 0.8)';
            } else {
                espStatusDiv.classList.add('success');
            }

            if (!isPending) {
                setTimeout(() => {
                    espStatusDiv.style.display = 'none';
                }, 3000);
            }
        }
        
        // --- Helper for Physical Replay ---
        function sendPhysicalCommandsForState(state, forDemo = false) {
            if (!state) { console.warn("sendPhysicalCommandsForState: No state provided."); return; }
            
            const baseRotationUI = parseFloat(forDemo ? state.base : state.baseRotation);
            if (!isNaN(baseRotationUI)) {
                const baseAngle = parseInt(baseRotationUI.toFixed(0));
                 sendServoCommand("base", baseAngle);
            } else {
                console.error("sendPhysicalCommandsForState: Invalid baseRotation in state", state);
            }
            
            const arm1Pitch_UI = parseFloat(forDemo ? state.pitch : state.arm1Pitch); // This is ui_pitch
            if (!isNaN(arm1Pitch_UI)) {
                const physicalArm1Angle = calculatePhysicalPitchAngle(arm1Pitch_UI);
                sendServoCommand("arm1", parseInt(physicalArm1Angle.toFixed(0)));
                if (isReplaying || isDemoReplaying) { // Only log during active replay/demo to reduce console noise
                     console.log(`State CMD: Arm1 UI pitch ${arm1Pitch_UI.toFixed(1)}° => Physical ${physicalArm1Angle.toFixed(1)}°`);
                }
            } else {
                console.error("sendPhysicalCommandsForState: Invalid arm1Pitch in state", state);
            }
        }

        // --- Event Handlers & UI Logic ---
        function handleHoldDurationChange() {
            const newHoldSeconds = parseFloat(holdDurationInput.value);
            if (!isNaN(newHoldSeconds) && newHoldSeconds >= parseFloat(holdDurationInput.min) && newHoldSeconds <= parseFloat(holdDurationInput.max)) {
                currentHoldDurationMs = newHoldSeconds * 1000;
                holdDurationValueSpan.textContent = `${newHoldSeconds.toFixed(1)}s`;
            } else if (newHoldSeconds < parseFloat(holdDurationInput.min)) {
                holdDurationInput.value = holdDurationInput.min;
                currentHoldDurationMs = parseFloat(holdDurationInput.min) * 1000;
                holdDurationValueSpan.textContent = `${parseFloat(holdDurationInput.min).toFixed(1)}s`;
            } else if (newHoldSeconds > parseFloat(holdDurationInput.max)) {
                 holdDurationInput.value = holdDurationInput.max;
                currentHoldDurationMs = parseFloat(holdDurationInput.max) * 1000;
                holdDurationValueSpan.textContent = `${parseFloat(holdDurationInput.max).toFixed(1)}s`;
            }
        }

        function handleSliderInput(event) {
            if (isReplaying || isDemoReplaying) return;
            const sliderId = event.target.id;
            const value = parseFloat(event.target.value); 

            switch (sliderId) {
                case 'baseRotation': // value is 0-180 physical base angle
                    servoBase.rotation.y = THREE.MathUtils.degToRad(value);
                    baseRotationValueSpan.textContent = `${parseInt(value)}°`;
                    sendServoCommand("base", parseInt(value));
                    break;
                case 'arm1Pitch': // value is ui_pitch from -60 to +90
                    arm1Pivot.rotation.x = THREE.MathUtils.degToRad(value); // Update 3D model with ui_pitch
                    const physicalArm1Angle = calculatePhysicalPitchAngle(value);
                    arm1PitchValueSpan.textContent = `${parseInt(physicalArm1Angle.toFixed(0))}°`; // Display physical angle
                    sendServoCommand("arm1", parseInt(physicalArm1Angle.toFixed(0)));
                    console.log(`Slider CMD: Arm1 UI pitch ${value.toFixed(1)}° => Physical ${physicalArm1Angle.toFixed(1)}°`);
                    break;
                case 'waterSpeed':
                    waterBaseSpeed = value;
                    waterSpeedValueSpan.textContent = waterBaseSpeed.toFixed(0);
                    break;
            }
        }
        function toggleWater() {
             if (isReplaying || isDemoReplaying) return;
            isWatering = !isWatering;
            particleSystem.visible = isWatering;
            updateWaterButton();
            if (isWatering) {
                resetWaterParticles();
            }
        }
        function updateWaterButton() {
             if (isWatering) {
                 waterToggleButton.textContent = 'Water ON';
                 waterToggleButton.classList.remove('off');
             } else {
                 waterToggleButton.textContent = 'Water OFF';
                 waterToggleButton.classList.add('off');
             }
        }
        function savePosition() {
             if (isReplaying || isDemoReplaying) return;
            const currentBaseRotationDeg = THREE.MathUtils.radToDeg(servoBase.rotation.y);
            const currentArm1PitchDeg_UI = THREE.MathUtils.radToDeg(arm1Pivot.rotation.x); // This is ui_pitch
            const currentState = {
                baseRotation: parseFloat(currentBaseRotationDeg.toFixed(1)),
                arm1Pitch: parseFloat(currentArm1PitchDeg_UI.toFixed(1)), // Save ui_pitch
                waterSpeed: waterBaseSpeed,
                isWatering: isWatering
            };
            savedSequence.push(currentState);
            updateSequenceInfo();
        }
        function clearSequence() {
            if (isReplaying || isDemoReplaying) return;
            if (confirm("Are you sure you want to clear the saved sequence?")) {
                 savedSequence = [];
                 updateSequenceInfo();
                 if (isReplaying) {
                     endReplay();
                 }
            }
        }
        function updateSequenceInfo() {
            sequenceInfoSpan.textContent = `Saved: ${savedSequence.length}`;
            const noSequence = savedSequence.length === 0;
            replaySequenceButton.disabled = isReplaying || isDemoReplaying || noSequence;
            clearSequenceButton.disabled = isReplaying || isDemoReplaying || noSequence;
            // demoSequenceButton is handled by toggleUIControls
        }

        function updateSliderDisplays() {
            // Base rotation
            const currentBaseDeg = THREE.MathUtils.radToDeg(servoBase.rotation.y);
            baseRotationValueSpan.textContent = `${currentBaseDeg.toFixed(0)}°`;
            baseRotationSlider.value = currentBaseDeg.toFixed(0);

            // Arm Pitch
            const currentArm1PitchDeg_UI = THREE.MathUtils.radToDeg(arm1Pivot.rotation.x); // Current ui_pitch from 3D model
            const physicalArm1PitchDeg_Display = calculatePhysicalPitchAngle(currentArm1PitchDeg_UI);
            
            arm1PitchValueSpan.textContent = `${parseInt(physicalArm1PitchDeg_Display.toFixed(0))}°`; // Display calculated physical
            arm1PitchSlider.value = currentArm1PitchDeg_UI.toFixed(0); // Set slider to current ui_pitch

            // Water speed
            waterSpeedValueSpan.textContent = `${waterBaseSpeed.toFixed(0)}`;
            waterSpeedSlider.value = waterBaseSpeed.toFixed(0);
         }

        // --- Replay Logic ---
        function lerp(start, end, t) { return start * (1 - t) + end * t; }

        function startReplay() {
            if (isReplaying || isDemoReplaying || savedSequence.length === 0) { return; }
            isReplaying = true;
            isHoldingAtPosition = false;
            replayStepIndex = 0;
            toggleUIControls(false);

            startState = { // Current visual state (base is physical, arm1Pitch is ui_pitch)
                baseRotation: THREE.MathUtils.radToDeg(servoBase.rotation.y),
                arm1Pitch: THREE.MathUtils.radToDeg(arm1Pivot.rotation.x), // ui_pitch
                waterSpeed: waterBaseSpeed,
                isWatering: isWatering
            };
            targetState = savedSequence[replayStepIndex]; // Contains ui_pitch for arm1Pitch

            const previousWateringState = isWatering;
            isWatering = targetState.isWatering;
            particleSystem.visible = isWatering;
            updateWaterButton();
            if (isWatering && !previousWateringState) { resetWaterParticles(); }

            sendPhysicalCommandsForState(targetState); 

            transitionStartTime = performance.now();
            replayStatusDiv.textContent = `Transitioning to Step ${replayStepIndex + 1} of ${savedSequence.length}...`;
            replayStatusDiv.style.display = 'block';
            animateTransitionStep(transitionStartTime);
        }

        function animateTransitionStep(currentTime) {
            if (!isReplaying) return;

            if (isHoldingAtPosition) {
                const holdingTimeElapsed = currentTime - holdStartTime;
                if (holdingTimeElapsed >= currentHoldDurationMs) {
                    isHoldingAtPosition = false;
                    replayStepIndex++;
                    if (replayStepIndex < savedSequence.length) {
                        startState = targetState; 
                        targetState = savedSequence[replayStepIndex];

                        const previousWateringState = isWatering;
                        isWatering = targetState.isWatering;
                        particleSystem.visible = isWatering;
                        updateWaterButton();
                        if (isWatering && !previousWateringState) { resetWaterParticles(); }

                        sendPhysicalCommandsForState(targetState);

                        transitionStartTime = currentTime; 
                        replayStatusDiv.textContent = `Transitioning to Step ${replayStepIndex + 1} of ${savedSequence.length}...`;
                    } else {
                        endReplay();
                        return;
                    }
                } else { 
                    const holdingTimeRemaining = Math.max(0, (currentHoldDurationMs - holdingTimeElapsed) / 1000);
                    replayStatusDiv.textContent = `Holding at Step ${replayStepIndex + 1} (${holdingTimeRemaining.toFixed(1)}s)...`;
                    transitionFrameId = requestAnimationFrame(animateTransitionStep);
                    return;
                }
            }

            if (!startState || !targetState) { endReplay(); return; }

            const elapsedTimeForTransition = currentTime - transitionStartTime;
            let t = Math.min(elapsedTimeForTransition / transitionDuration, 1);

            // Lerp base rotation (physical) and arm1Pitch (ui_pitch)
            const currentBaseRotationDeg = lerp(startState.baseRotation, targetState.baseRotation, t);
            const currentArm1PitchDeg_UI = lerp(startState.arm1Pitch, targetState.arm1Pitch, t); // Lerping ui_pitch
            waterBaseSpeed = lerp(startState.waterSpeed, targetState.waterSpeed, t);

            servoBase.rotation.y = THREE.MathUtils.degToRad(currentBaseRotationDeg);
            arm1Pivot.rotation.x = THREE.MathUtils.degToRad(currentArm1PitchDeg_UI); // Apply lerped ui_pitch to 3D model

            updateSliderDisplays(); // Reflect visual changes, will calculate physical pitch for display

            if (t < 1) {
                transitionFrameId = requestAnimationFrame(animateTransitionStep);
            } else { 
                isHoldingAtPosition = true;
                holdStartTime = currentTime;

                // Ensure arm is exactly at target state visually (ui_pitch for arm)
                servoBase.rotation.y = THREE.MathUtils.degToRad(targetState.baseRotation);
                arm1Pivot.rotation.x = THREE.MathUtils.degToRad(targetState.arm1Pitch); // ui_pitch
                waterBaseSpeed = targetState.waterSpeed;
                isWatering = targetState.isWatering;
                particleSystem.visible = isWatering;
                updateWaterButton();
                updateSliderDisplays(); // final update for this step

                const initialHoldingTimeDisplay = (currentHoldDurationMs / 1000);
                replayStatusDiv.textContent = `Holding at Step ${replayStepIndex + 1} (${initialHoldingTimeDisplay.toFixed(1)}s)...`;
                transitionFrameId = requestAnimationFrame(animateTransitionStep);
            }
        }

        function endReplay() {
            isReplaying = false;
            isHoldingAtPosition = false;
            startState = null;
            targetState = null;
            if (transitionFrameId) {
                cancelAnimationFrame(transitionFrameId);
                transitionFrameId = null;
            }
            replayStatusDiv.style.display = 'none';
            toggleUIControls(true); 

            if (savedSequence.length > 0) {
                const finalState = savedSequence[savedSequence.length - 1];
                servoBase.rotation.y = THREE.MathUtils.degToRad(finalState.baseRotation);
                arm1Pivot.rotation.x = THREE.MathUtils.degToRad(finalState.arm1Pitch); // ui_Pitch
                waterBaseSpeed = finalState.waterSpeed;
                isWatering = finalState.isWatering;
                particleSystem.visible = isWatering;
                updateSliderDisplays();
                updateWaterButton();
            }
             updateSequenceInfo(); 
        }

        // --- Demo Replay Logic ---
        function toggleDemoReplay() {
            if (isReplaying) return; 

            isDemoReplaying = !isDemoReplaying; 

            if (isDemoReplaying) {
                if (demoSequence.length === 0) {
                    isDemoReplaying = false; 
                    return;
                }
                demoStepIndex = 0;
                toggleUIControls(false); 
                demoSequenceButton.textContent = "Stop Demo";
                demoSequenceButton.classList.add("active");
                demoStatusDiv.style.display = 'block';
                
                isWatering = false; // Default water OFF for demo
                particleSystem.visible = isWatering;
                updateWaterButton();

                console.log("Demo Loop Started");
                processDemoStep();
            } else {
                terminateDemoLoop();
            }
        }

        function processDemoStep() {
            if (!isDemoReplaying) return; 

            if (demoStepIndex >= demoSequence.length) {
                demoStepIndex = 0; // Loop
            }

            const step = demoSequence[demoStepIndex]; // step.pitch is ui_pitch
            const physicalPitchForDisplay = calculatePhysicalPitchAngle(step.pitch);
            demoStatusDiv.textContent = `Demo: Base ${step.base}°, UI Pitch ${step.pitch}° (Phys: ${physicalPitchForDisplay.toFixed(0)}°) - Step ${demoStepIndex + 1}/${demoSequence.length}`;

            servoBase.rotation.y = THREE.MathUtils.degToRad(step.base);
            arm1Pivot.rotation.x = THREE.MathUtils.degToRad(step.pitch); // Set 3D model to ui_pitch

            updateSliderDisplays(); // Update sliders to reflect current demo step's ui_pitch
            sendPhysicalCommandsForState(step, true); // Sends commands based on step's ui_pitch

            demoStepIndex++;
            demoTimeoutId = setTimeout(processDemoStep, demoStepDelay);
        }

        function terminateDemoLoop() {
            isDemoReplaying = false; 
            if (demoTimeoutId) {
                clearTimeout(demoTimeoutId);
                demoTimeoutId = null;
            }
            demoSequenceButton.textContent = "Play Demo";
            demoSequenceButton.classList.remove("active");
            demoStatusDiv.style.display = 'none';
            toggleUIControls(true); 
            console.log("Demo Loop Terminated");
            updateSequenceInfo();
        }

        function toggleUIControls(enabled) {
            const otherReplayActive = isReplaying || isDemoReplaying;

            espIpAddressInput.disabled = !enabled || otherReplayActive;
            baseRotationSlider.disabled = !enabled || otherReplayActive;
            arm1PitchSlider.disabled = !enabled || otherReplayActive;
            waterSpeedSlider.disabled = !enabled || otherReplayActive;
            waterToggleButton.disabled = !enabled || otherReplayActive;
            savePositionButton.disabled = !enabled || otherReplayActive;
            holdDurationInput.disabled = !enabled || otherReplayActive;
            orbitControls.enabled = enabled && !otherReplayActive;

            const noSequence = savedSequence.length === 0;
            replaySequenceButton.disabled = !enabled || isDemoReplaying || noSequence || isReplaying;
            clearSequenceButton.disabled = !enabled || isDemoReplaying || noSequence || isReplaying;
            demoSequenceButton.disabled = !enabled || isReplaying; 

            if (enabled && !isReplaying) { // If enabling controls and no regular replay, demo button should be enabled
                 demoSequenceButton.disabled = false;
            }
            if (isDemoReplaying) { // If demo is active, ensure other replay buttons are off
                replaySequenceButton.disabled = true;
                clearSequenceButton.disabled = true;
            }
        }

        // --- Animation & Update ---
        function animate() {
            requestAnimationFrame(animate);
            if (!isReplaying && !isDemoReplaying) {
                orbitControls.update();
            }
            if (isWatering && particleSystem.visible) {
                 updateWaterParticles();
            }
            renderer.render(scene, camera);
        }

        // --- Water Particle Logic ---
        function updateWaterParticles() {
            if (!particleSystem || !particleSystem.visible) return;
            const positionsAttribute = particleSystem.geometry.attributes.position;
            const positionsArray = positionsAttribute.array;
            const velocitiesArray = particleSystem.geometry.userData.velocities;
            const emitterWorldPosition = new THREE.Vector3();
            const emitterWorldQuaternion = new THREE.Quaternion();
            const emitterWorldDirection = new THREE.Vector3();
            arm1Emitter.getWorldPosition(emitterWorldPosition);
            arm1Emitter.getWorldQuaternion(emitterWorldQuaternion);
            emitterWorldDirection.set(0, 1, 0).applyQuaternion(emitterWorldQuaternion).normalize(); // Y-up local emitter direction
            const gravity = new THREE.Vector3(0, -9.8, 0);
            const damping = 0.98;
            const dt = 0.016;
            let textureNeedsUpdate = false;
            for (let i = 0; i < waterParticleCount; i++) {
                const index = i * 3;
                let pVelocity = velocitiesArray[i];
                let pX = positionsArray[index];
                let pY = positionsArray[index + 1];
                let pZ = positionsArray[index + 2];
                if (pY < 0 && pVelocity.y < 0) { // Particle hit ground
                    const hitX = pX;
                    const hitZ = pZ;
                    const texX = Math.floor(((hitX / lawnWidth) + 0.5) * lawnTextureSize);
                    const texY = Math.floor(((-hitZ / lawnHeight) + 0.5) * lawnTextureSize); // Invert Z for texture Y
                    if (texX >= 0 && texX < lawnTextureSize && texY >= 0 && texY < lawnTextureSize) {
                        lawnTextureContext.fillStyle = wetLawnColor;
                        lawnTextureContext.beginPath();
                        lawnTextureContext.arc(texX, texY, 2, 0, Math.PI * 2);
                        lawnTextureContext.fill();
                        textureNeedsUpdate = true;
                    }
                    // Reset particle
                    positionsArray[index]     = emitterWorldPosition.x;
                    positionsArray[index + 1] = emitterWorldPosition.y;
                    positionsArray[index + 2] = emitterWorldPosition.z;
                    pVelocity.set(0, 0, 0); 
                }
                if (pVelocity.lengthSq() === 0) { // If particle is reset (e.g. hit ground or new)
                    positionsArray[index]     = emitterWorldPosition.x;
                    positionsArray[index + 1] = emitterWorldPosition.y;
                    positionsArray[index + 2] = emitterWorldPosition.z;
                    const speedVariation = waterBaseSpeed * 0.2;
                    const currentSpeed = waterBaseSpeed + (Math.random() - 0.5) * speedVariation;
                    const spreadFactor = 0.2; 
                    pVelocity.copy(emitterWorldDirection)
                           .multiplyScalar(currentSpeed)
                           .add(new THREE.Vector3(
                               (Math.random() - 0.5) * spreadFactor * currentSpeed,
                               (Math.random() - 0.5) * spreadFactor * currentSpeed * 0.5, 
                               (Math.random() - 0.5) * spreadFactor * currentSpeed
                           ));
                }
                if (pVelocity.lengthSq() > 0) { 
                    pVelocity.addScaledVector(gravity, dt); 
                    pVelocity.multiplyScalar(damping);      
                    positionsArray[index]     += pVelocity.x * dt;
                    positionsArray[index + 1] += pVelocity.y * dt;
                    positionsArray[index + 2] += pVelocity.z * dt;
                }
            }
            positionsAttribute.needsUpdate = true;
            if (textureNeedsUpdate) {
                lawnTexture.needsUpdate = true;
            }
        }
        function resetWaterParticles() {
             if (!particleSystem) return;
             const positions = particleSystem.geometry.attributes.position.array;
             const velocities = particleSystem.geometry.userData.velocities;
             const emitterWorldPosition = new THREE.Vector3();
             arm1Emitter.getWorldPosition(emitterWorldPosition); 
             for (let i = 0; i < waterParticleCount; i++) {
                 const index = i * 3;
                 positions[index] = emitterWorldPosition.x;
                 positions[index + 1] = emitterWorldPosition.y;
                 positions[index + 2] = emitterWorldPosition.z;
                 if (velocities[i]) { 
                    velocities[i].set(0, 0, 0); 
                 }
             }
             particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
         window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>